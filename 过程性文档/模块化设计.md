# 模块化设计文档

## 1. 设计概述

### 1.1 设计目标

本项目采用模块化架构设计，基于**表单式多槽位采集 + YAML-DSL流程定义**的混合架构，旨在实现以下目标：

- **高内聚低耦合**：各模块职责明确，接口清晰
- **可扩展性**：易于添加新业务场景（通过JSON配置和YAML流程）
- **可维护性**：代码与配置分离，便于调试和测试
- **可测试性**：完整的测试套件，支持单元测试、集成测试和端到端测试
- **声明式配置**：业务逻辑通过YAML DSL定义，无需修改代码

### 1.2 架构原则

- **接口隔离**：定义清晰的接口规范（ILLMClient, IKnowledgeProvider）
- **配置驱动**：业务配置（JSON）+ 流程配置（YAML）双层配置体系
- **分层抽取**：直接匹配 → 意图推荐 → LLM兜底的三层信息提取策略
- **状态机管理**：订单状态机（COLLECTING → READY_CONFIRM → AWAITING_CONTINUE）
- **动态过滤**：基于上游槽位的枚举选项动态过滤（series/size/chip/storage）

## 2. 模块架构设计

### 2.1 整体模块结构

```
src/
├── core/                          # 核心抽象层
│   ├── interfaces.py              # 接口定义（SlotSpec, ILLMClient, IKnowledgeProvider）
│   ├── form_based_system.py       # 表单式多槽位对话系统核心
│   ├── slot_specs.py              # 槽位规格定义与候选列表
│   ├── slot_validators.py         # 槽位验证器（组合验证）
│   └── enum_registry.py           # 枚举注册中心（已废弃，由JSON配置替代）
├── config/                        # 配置层
│   └── settings.py                # 全局配置管理（LLM API、路径等）
├── dsl/                           # DSL解析与执行层
│   ├── yaml_flow_loader.py        # YAML流程定义加载器
│   └── flow_interpreter.py        # 流程解释器（DSL执行引擎）
├── knowledge/                     # 知识与配置管理层
│   ├── business_config_loader.py  # 统一业务配置加载器（JSON）
│   └── business_configs/          # 业务配置目录
│       ├── apple_store.json       # 苹果商店业务配置
│       └── dining.json            # 餐饮预订业务配置
├── semantics/                     # 语义映射层
│   └── option_mapping.py          # 语义选项构建器（OptionBuilder）
├── llm/                           # 外部服务层
│   └── spark_client.py            # 讯飞星火LLM客户端
├── scripts/                       # DSL脚本资源层
│   ├── apple_store.flow.yaml      # 苹果商店YAML流程定义
│   └── dining.flow.yaml           # 餐饮预订YAML流程定义
└── main.py                        # 应用主入口（YAML-DSL驱动）
```

### 2.2 模块依赖关系

```
main.py (应用入口，选择YAML流程)
    ↓
dsl/yaml_flow_loader.py (加载YAML流程定义)
    ↓
knowledge/business_config_loader.py (注入槽位规格到业务配置)
    ↓
dsl/flow_interpreter.py (流程解释器)
    ├── core/form_based_system.py (表单系统核心)
    │   ├── core/slot_specs.py (槽位定义)
    │   ├── core/slot_validators.py (验证器)
    │   ├── semantics/option_mapping.py (语义映射)
    │   └── knowledge/business_config_loader.py (枚举、模板、过滤器)
    └── llm/spark_client.py (LLM服务)
```

## 3. 核心接口与数据结构设计

### 3.1 SlotSpec 数据类（槽位规格）

```python
@dataclass
class SlotSpec:
    """槽位规格定义 - 描述单个信息槽位的所有属性"""
    name: str                          # 槽位名称（category/brand/series等）
    required: bool                      # 是否必填
    description: str                    # 描述文本（用于提示）
    dependencies: List[str]             # 依赖的上游槽位列表
    enums_key: Optional[str] = None    # 枚举键（从配置加载候选值）
    semantic_stage: Optional[str] = None  # 语义映射阶段标识
    allow_llm: bool = True             # 是否允许LLM填充
```

**设计意义**：

- 声明式定义槽位属性，支持从JSON/YAML加载
- `dependencies` 实现槽位依赖链（如 series 依赖 brand）
- `enums_key` 关联业务配置中的枚举定义
- `semantic_stage` 支持动态语义过滤（如 chip 根据 series 过滤）

### 3.2 ILLMClient 接口

```python
class ILLMClient(ABC):
    """LLM客户端接口 - 负责与大型语言模型API交互"""
  
    @abstractmethod
    def detect_intent(self, 
                     user_input: str, 
                     available_intents: Dict[str, str], 
                     context: Optional[Dict[str, Any]] = None) -> str:
        """使用LLM检测用户输入的意图（支持上下文）"""
  
    @abstractmethod
    def extract_slots(self,
                     user_input: str,
                     business_line: str,
                     target_slots: List[str],
                     current_values: Dict[str, Any]) -> Dict[str, Any]:
        """从自然语言中抽取多个槽位信息"""
```

**职责**：

- 意图识别（废弃，当前直接使用表单流程）
- 多槽位信息抽取（Layer 3兜底）
- 返回格式: `{slot_name: {"value": "...", "confidence": 0.8, "reason": "..."}}`

### 3.3 IKnowledgeProvider 接口（已废弃）

当前实现通过 `BusinessConfigLoader` 统一管理业务配置，不再使用独立的 `IKnowledgeProvider` 接口。

### 3.4 FormBasedDialogSystem 核心类

```python
class FormBasedDialogSystem:
    """表单式多槽位对话系统核心"""
    
    def __init__(self, business_line: str):
        """初始化并加载业务配置（slot_specs/enums/filters/templates）"""
    
    def process_input(self, user_input: str, llm_client, semantic_mapper) -> Dict[str, Any]:
        """
        处理用户输入的核心方法
        Returns:
            {
                "slots_updated": [],     # 更新的槽位列表
                "slots_filled": [],      # 填充完成的槽位列表
                "conflicts": [],         # 冲突记录
                "response": "",          # 系统响应文本
                "form_complete": bool,   # 表单是否完整
                "should_exit": bool      # 是否应退出对话
            }
        """
```

**核心流程**：

1. **命令处理**：识别确认/重选/继续购物/退出命令
2. **数字选择**：基于 `last_prompted_slot` 映射序号到枚举值
3. **三层抽取**：
   - Layer 1：直接关键词匹配（`_direct_keyword_extraction`）
   - Layer 2：意图推荐（`_intent_based_recommendation`）+ 语义映射（`_semantic_slot_extraction`）
   - Layer 3：LLM兜底抽取（`_llm_slot_extraction`）
4. **冲突检测**：来源优先级 + 置信度判定
5. **验证与完成性**：槽位验证器 + 表单完整性检查
6. **状态机**：COLLECTING → READY_CONFIRM → AWAITING_CONTINUE

### 3.5 YAMLFlowLoader 类

```python
class YAMLFlowLoader:
    """YAML格式的流程定义加载器"""
    
    @staticmethod
    def load(yaml_file: str) -> Dict[str, Any]:
        """加载并验证YAML流程定义文件"""
    
    @staticmethod
    def validate(flow_config: Dict[str, Any]) -> bool:
        """验证流程配置的完整性（必需字段、槽位定义等）"""
```

**YAML DSL 结构**：

```yaml
flow:
  name: apple_shopping
  version: "1.0"
  business_line: apple_store
  
  process_order:  # 槽位填充顺序
    - category
    - brand
    - series
    
  slots:          # 槽位定义
    category:
      label: "产品大类"
      required: true
      enums_key: category
      dependencies: []
      
  events:         # 生命周期事件
    on_start: 
      - say: "欢迎光临"
```

### 3.6 FlowInterpreter 类

```python
class FlowInterpreter:
    """流程解释器 - DSL执行引擎"""
    
    def __init__(self, flow_config: Dict, form_system: FormBasedDialogSystem):
        """绑定YAML流程配置与表单系统"""
    
    def process_input(self, user_input: str, llm_client, semantic_mapper) -> Dict:
        """执行流程，委托表单系统处理"""
    
    def _execute_event(self, event_name: str):
        """执行YAML定义的事件动作（on_start/on_complete等）"""
```

## 4. 配置管理设计

### 4.1 双层配置体系

#### 业务配置（JSON）- src/knowledge/business_configs/*.json

```json
{
  "business_info": {
    "name": "apple_store",
    "display_name": "苹果专卖店",
    "description": "苹果全系产品销售与配置"
  },
  "slot_specs": [ /* 槽位定义数组 */ ],
  "enums": {
    "category": [
      {"label": "电脑", "aliases": ["电脑", "笔记本", "mac", "macbook"]},
      {"label": "手机", "aliases": ["手机", "iphone", "苹果手机"]}
    ],
    "series": [ /* 产品系列枚举 */ ]
  },
  "filters": {
    "series_by_category": {
      "电脑": ["MacBook Air", "MacBook Pro", "iMac"],
      "手机": ["iPhone 16 Pro 系列", "iPhone 16 系列"]
    },
    "chip_by_category": { /* 芯片按类别过滤 */ }
  },
  "intent_recommendations": {
    "chip": [
      {
        "keywords": ["视频", "剪辑"],
        "recommend": "M3 Pro",
        "confidence": 0.75
      }
    ]
  },
  "templates": {
    "form_welcome": ["欢迎光临苹果专卖店..."],
    "form_category_prompt": ["先选一个方向吧..."]
  },
  "command_keywords": {
    "confirm": ["确认", "确认订单", "ok"],
    "reselect": ["重选", "修改"],
    "restart": ["继续购物", "重新开始"]
  }
}
```

#### 流程配置（YAML）- src/scripts/*.flow.yaml

```yaml
flow:
  name: apple_shopping
  version: "1.0"
  business_line: apple_store
  
  process_order:
    - category
    - brand
    - series
    - size
    - chip
    - storage
    - color
  
  slots:
    category:
      label: "产品大类"
      required: true
      enums_key: category
      dependencies: []
      allow_llm: false
      
    series:
      label: "产品系列"
      required: true
      enums_key: series
      semantic_stage: series_selection
      dependencies: [brand]
      
  events:
    on_start:
      - say: "欢迎光临，今天想挑点什么呢～"
    on_complete:
      - say: "订单已生成，感谢惠顾！"
```

**配置分工**：

- JSON：业务数据（枚举、别名、过滤规则、模板、意图推荐）
- YAML：流程定义（槽位顺序、依赖关系、事件钩子）

### 4.2 BusinessConfigLoader 统一加载器

```python
class BusinessConfigLoader:
    """统一业务配置加载器"""
    
    def __init__(self, config_dir: str = "src/knowledge/business_configs"):
        """加载所有 .json 业务配置"""
    
    def get_slot_specs(self, business_name: str) -> List[SlotSpec]:
        """获取槽位规格列表"""
    
    def inject_slot_specs(self, business_name: str, slot_specs: List[SlotSpec]):
        """动态注入槽位规格（用于YAML DSL）"""
    
    def get_enums(self, business_name: str) -> Dict[str, List[Dict]]:
        """获取枚举定义"""
    
    def get_intent_recommendations(self, business_name: str) -> Dict:
        """获取意图推荐配置"""
    
    def get_template(self, business_name: str, template_key: str) -> List[str]:
        """获取响应模板"""
```

### 4.3 Config 全局配置类

```python
class Config:
    """集中式配置管理 - 单例模式确保配置一致性"""
  
    # LLM配置
    @staticmethod
    def get_llm_config():
        return {
            "app_id": os.getenv("SPARK_APP_ID"),
            "api_key": os.getenv("SPARK_API_KEY"),
            "api_secret": os.getenv("SPARK_API_SECRET"),
            "spark_url": "wss://spark-api.xf-yun.com/v4.0/chat"
        }
  
    # 业务配置
    MAX_HISTORY_LENGTH = 10
    RESPONSE_TIMEOUT = 30
```

**设计特点**：

- **环境变量支持**：通过环境变量覆盖默认配置（API密钥等）
- **类型安全**：明确的配置项和默认值
- **易于扩展**：新增配置项无需修改使用代码

## 5. 三层信息抽取策略设计

### 5.1 抽取层次架构

```
用户输入: "我想要 MacBook Pro 1T 午夜色"
    ↓
Layer 1: 直接关键词匹配
    → 扫描所有槽位的别名映射（精确/边界匹配）
    → series="MacBook Pro" (直接匹配)
    → storage="1TB" (别名"1T"→"1TB")
    → color="午夜色" (直接匹配)
    ↓
Layer 2: 意图推荐 + 语义映射
    → 检测关键词"视频剪辑" → chip="M3 Pro" (意图推荐)
    → semantic_stage="chip_select" → 根据series过滤芯片候选
    ↓
Layer 3: LLM兜底抽取
    → 复杂/模糊表达交给LLM全局理解
    → 返回 {slot: {value, confidence, reason}}
```

### 5.2 Layer 1: 直接关键词匹配

```python
def _direct_keyword_extraction(self, user_input: str) -> Dict[str, SlotValue]:
    """
    策略：
    - 遍历所有EMPTY槽位的枚举定义
    - 对每个枚举项的别名进行精确/边界匹配
    - 收集所有匹配结果，按匹配长度和置信度消歧
    - 推断逻辑：series匹配时自动推断category和brand
    """
```

**特点**：

- 高置信度（0.95）
- 支持别名映射（"1T"→"1TB", "午夜"→"午夜色"）
- 边界匹配（避免"pro"误匹配"iphone 16 pro"）
- 仅扫描EMPTY槽位，避免干扰已填充内容

### 5.3 Layer 2: 意图推荐与语义映射

#### 意图推荐

```python
def _intent_based_recommendation(self, user_input: str, slot_name: str) -> Optional[SlotValue]:
    """
    基于intent_recommendations配置：
    {
      "chip": [
        {"keywords": ["视频", "剪辑"], "recommend": "M3 Pro", "confidence": 0.75}
      ]
    }
    """
```

#### 语义映射

```python
def _semantic_slot_extraction(self, user_input: str, slot_name: str, semantic_mapper):
    """
    使用OptionBuilder动态构建候选：
    - semantic_stage="chip_select" → 根据当前series过滤芯片
    - 调用语义映射器匹配最佳选项
    """
```

### 5.4 Layer 3: LLM兜底抽取

```python
def _llm_slot_extraction(self, user_input: str, target_slots: List[str], llm_client):
    """
    提交给LLM的Prompt结构：
    - 当前业务线：apple_store
    - 目标槽位：[chip, storage, color]
    - 已填槽位：{category: "电脑", series: "MacBook Pro"}
    - 用户输入："我想要高性能配置"
    
    LLM返回格式：
    {
      "chip": {"value": "M3 Pro", "confidence": 0.8, "reason": "高性能需求"},
      "storage": {"value": "1TB", "confidence": 0.7, "reason": "专业用途"}
    }
    """
```

**LLM校验机制**：

- `allow_llm` 白名单控制
- 置信度过滤（< 0.35 拒收）
- 枚举有效性验证（`_validate_enum_value`）
- 低优先级（精确匹配 > 意图推荐 > LLM）

### 5.5 优先级与冲突处理

```
来源优先级（高→低）：
1. direct (0.95)
2. numeric/single_match (0.9)
3. semantic (0.75)
4. intent_recommend (0.7)
5. llm/multi_llm (0.6-0.8)

冲突触发条件：
- 新值confidence ≥ 0.6 且 value ≠ 旧值
- 不同来源优先级相近时
- AI vs 直接识别冲突必定触发

冲突决策：
1 → 保留旧值
2 → 使用新值（清空下游依赖）
3 → 清空该槽位，等待重新输入
```

## 6. 订单状态机与命令处理

### 6.1 状态机设计

```
COLLECTING (收集信息)
    ↓ [所有必填槽位已填充 + 验证通过]
READY_CONFIRM (准备确认)
    ↓ [用户输入"确认"命令]
CONFIRMED (已确认) → AWAITING_CONTINUE (等待继续)
    ↓ [用户输入"继续购物"]
COLLECTING (重置表单，开始新订单)
    
    或 [用户输入"再见"]
    → should_exit=True (退出对话)
```

### 6.2 命令处理逻辑

#### 确认命令

```python
if normalized in confirm_keywords and self.order_status == OrderStatus.READY_CONFIRM:
    # 1. 检查表单完整性
    # 2. 运行验证器（组合规则校验）
    # 3. 生成订单摘要
    # 4. 切换到 AWAITING_CONTINUE 状态
```

#### 重选命令

```python
if normalized in reselect_keywords and self.order_status == OrderStatus.READY_CONFIRM:
    # 1. 展示已填槽位列表（带序号）
    # 2. 等待用户输入序号
    # 3. 清空选中槽位及其依赖链
    # 4. 重新提示该槽位
```

#### 继续购物命令

```python
if normalized in restart_keywords:
    # 1. 重置所有槽位状态
    # 2. 清空冲突与验证错误
    # 3. 回到 COLLECTING 状态
    # 4. 提示首个必填槽位
```

### 6.3 数字选择映射

```python
if stripped.isdigit():
    number = int(stripped)
    
    # 场景1：冲突决策（1/2/3）
    if self.awaiting_conflict_slot:
        # 1=保留 2=使用新值 3=清空重说
    
    # 场景2：重选槽位选择
    if self.reselect_slot == "waiting":
        # 输入序号选择要修改的槽位
    
    # 场景3：确认菜单选择
    if self.order_status == OrderStatus.READY_CONFIRM:
        # 1=确认 2=重选 3=重新开始
    
    # 场景4：枚举选项序号
    if self.last_prompted_slot:
        # 基于过滤后枚举做序号映射
```

## 7. 动态枚举过滤设计

### 7.1 过滤规则配置（filters字段）

```json
"filters": {
  "series_by_category": {
    "电脑": ["MacBook Air", "MacBook Pro", "iMac"],
    "手机": ["iPhone 16 Pro 系列", "iPhone 16 系列"]
  },
  "chip_by_category": {
    "电脑": ["M3", "M3 Pro", "M3 Max"],
    "手机": ["A17 Pro", "A16"]
  },
  "size_by_series": {
    "MacBook Air": ["13寸", "15寸"],
    "MacBook Pro": ["14寸", "16寸"]
  }
}
```

### 7.2 动态过滤实现

```python
def _get_filtered_options(self, enum_key: str) -> List[Dict]:
    """
    根据已选上游槽位动态过滤枚举：
    
    - series → 按 category 过滤
    - size → 优先按 series 过滤，其次按 category
    - chip → 按 category 过滤
    - storage → 按 category 过滤
    """
    category = self.current_form.get("category").value.value if ... else None
    series = self.current_form.get("series").value.value if ... else None
    
    if enum_key == "series" and category:
        allowed = self.business_filters["series_by_category"].get(category)
        return [o for o in raw_options if o["label"] in allowed]
    
    if enum_key == "size" and series:
        allowed = self.business_filters["size_by_series"].get(series)
        return [o for o in raw_options if o["label"] in allowed]
```

**应用场景**：

- 提示生成：`_generate_slot_prompt` 使用过滤后枚举
- 数字映射：`_business_numeric_map` 基于过滤列表做序号映射
- 存储特殊处理：电脑不展示128GB/256GB，仅显示512GB/1TB/2TB

### 7.3 语义阶段过滤（semantic_stage）

```python
# YAML定义
slots:
  chip:
    semantic_stage: chip_selection  # 标记为语义过滤阶段
    
# OptionBuilder构建
def build(stage: str, context: Dict) -> List[Option]:
    if stage == "chip_selection":
        series = context.get("current_series")
        # 根据series动态构建芯片候选（比filters更灵活）
```

## 8. 测试策略

### 8.1 单元测试

- **接口测试**：验证接口契约
- **模块测试**：各模块独立功能测试
- **边界测试**：异常输入处理

### 8.2 集成测试

- **数据流测试**：模块间协作测试
- **端到端测试**：完整业务流程测试

## 9. 部署和配置

### 9.1 环境配置

```bash
# 环境变量配置
export SPARK_API_KEY="your_api_key"
export DSL_SCRIPT_PATH="path/to/script.dsl"
```

### 9.2 依赖管理

```txt
# requirements.txt
requests>=2.25.1
pyyaml>=5.4.0
```

## 10. 总结

本模块化设计通过清晰的接口定义和分层架构，实现了：

- ✅ **可维护性**：各模块职责单一，便于修改
- ✅ **可测试性**：接口隔离，支持单元测试
- ✅ **可扩展性**：易于添加新功能
- ✅ **可靠性**：完善的错误处理和降级策略

该设计为后续的功能扩展和性能优化奠定了良好的架构基础。
