# 🏗️ 架构规范手册

### 1. 模块职责边界规范

#### DSL解析器 (`dsl_parser.py`)

**职责**：纯语法解析，不涉及业务逻辑

```python
# ✅ 允许的功能
- 解析DSL文本为结构化数据
- 语法验证和错误报告
- 输出标准的AST结构

# ❌ 禁止的功能  
- 不能理解业务语义
- 不能执行任何动作
- 不能访问上下文或知识库
```

#### DSL解释器 (`interpreter.py`)

**职责**：规则执行引擎，不包含领域知识

```python
# ✅ 允许的功能
- 根据意图和上下文匹配规则
- 执行预定义的动作序列
- 管理对话状态流转

# ❌ 禁止的功能
- 不能硬编码业务逻辑
- 不能直接访问外部API
- 不能包含领域特定的判断
```

#### 知识库 (`*_knowledge.py`)

**职责**：纯数据提供，不参与流程控制

```python
# ✅ 允许的功能
- 提供领域数据和模板
- 数据验证和格式化
- 同义词映射和标准化

# ❌ 禁止的功能
- 不能决定对话流程
- 不能执行业务规则
- 不能修改上下文状态
```

#### LLM客户端 (`spark_client.py`)

**职责**：意图识别服务，不解释内容

```python
# ✅ 允许的功能
- 调用LLM API识别意图
- 提供上下文信息给LLM
- 实现降级识别策略

# ❌ 禁止的功能
- 不能解析DSL规则
- 不能执行业务动作
- 不能直接响应用户
```

### 2. 数据流规范

#### 严格的单向数据流

```
用户输入 → LLM意图识别 → 上下文更新 → 规则匹配 → 动作执行 → 响应输出
```

#### 上下文数据契约

```python
# 标准上下文结构
CONTEXT_SCHEMA = {
    "user_input": str,           # 当前用户输入
    "current_intent": str,       # 当前识别意图  
    "current_stage": str,        # 对话阶段
    "product_chain": List[Dict], # 选择路径
    "session_variables": Dict,   # 会话变量
    "conversation_history": List[Dict], # 对话历史
    "_manager": IContextManager, # 上下文管理器引用
    "knowledge": IKnowledgeProvider # 知识库引用
}
```

### 3. 错误处理规范

#### 分层错误处理

```python
class DSLSystem:
    def process_user_input(self, user_input: str) -> List[str]:
        try:
            # 1. 意图识别层错误
            intent = self.llm_client.detect_intent(user_input, self.available_intents, context)
        except IntentRecognitionError as e:
            return self._handle_intent_error(e)
          
        try:
            # 2. 规则执行层错误  
            responses = self.interpreter.execute(intent, context)
        except RuleExecutionError as e:
            return self._handle_execution_error(e)
          
        try:
            # 3. 动作执行层错误
            return self._validate_responses(responses)
        except ResponseValidationError as e:
            return self._handle_response_error(e)
```

#### 优雅降级策略

```python
def _get_fallback_response(self, error_type: str, context: Dict) -> List[str]:
    """根据错误类型提供合适的降级响应"""
    fallback_strategies = {
        "intent_unknown": self._ask_for_clarification,
        "rule_not_found": self._suggest_available_options, 
        "knowledge_missing": self._redirect_to_human_agent,
        "system_error": self._provide_technical_fallback
    }
    return fallback_strategies[error_type](context)
```

### 4. 扩展性规范

#### 动作系统扩展

```python
# 在解释器中注册新动作类型
self._action_handlers = {
    "respond": self._handle_respond,
    "set_variable": self._handle_set_variable,
    "add_to_chain": self._handle_add_to_chain,
    # 新动作在这里注册，不需要修改execute方法
    "new_custom_action": self._handle_custom_action
}
```

#### 条件系统扩展

```python
# 在匹配器中注册新条件类型  
self._condition_handlers = {
    "intent": self._match_intent_condition,
    "user_mention": self._match_user_mention,
    "context_eq": self._match_context_equality,
    # 新条件在这里注册
    "new_custom_condition": self._match_custom_condition
}
```

### 5. 测试驱动规范

#### 为每个模块定义测试契约

```python
# test_contracts.py
class DSLParserContract:
    """DSL解析器的测试契约"""
    def test_should_parse_intent_definitions(self):
        # 必须能正确解析INTENT语法
        pass
      
    def test_should_reject_invalid_syntax(self):
        # 必须拒绝语法错误的DSL
        pass

class InterpreterContract:
    """解释器的测试契约"""  
    def test_should_match_rules_by_intent_and_context(self):
        # 必须根据意图和上下文匹配规则
        pass
      
    def test_should_execute_actions_in_sequence(self):
        # 必须按顺序执行动作
        pass
```

### 6. DSL语言设计规范

#### 语法元素标准化

```dsl
# 意图定义规范
INTENT <intent_name>: "<description>"

# 规则结构规范  
RULE <rule_name>
WHEN <condition_expression>
[AND <additional_conditions>]*
THEN
<action_expression>+

# 条件表达式规范
<condition> ::= INTENT_IS <intent_name>
              | USER_MENTION "<keyword>"
              | USER_MENTION_ANY "<keyword1|keyword2>"
              | CONTEXT_EQ <var_name> = "<value>"
              | CONTEXT_NOT_SET <var_name>
              | CONTEXT_HAS "<var_name>" [= <value>]

# 动作表达式规范
<action> ::= RESPOND "<message>"
           | RESPOND_KB "<template_key>"
           | SET_VAR <var_name> = "<value>"
           | SET_STAGE "<stage_name>"
           | ADD_TO_CHAIN type = "<item_type>" value = "<item_value>"
           | RESET_SHOPPING_CONTEXT
```

### 7. 开发工作流规范

#### 添加新功能的检查清单

```
✅ 功能需求分析
✅ 接口设计（符合现有架构）
✅ 模块职责确认（不越界）
✅ 错误处理方案
✅ 测试用例设计
✅ 文档更新
```

#### 代码审查重点

```python
# 审查问题示例：
# ❌ "这个函数为什么直接调用了知识库？"
# ✅ "这个功能应该通过动作系统实现"

# ❌ "为什么在这里硬编码了业务逻辑？"  
# ✅ "这个逻辑应该移到DSL规则中"

# ❌ "这个模块为什么依赖了它不应该知道的东西？"
# ✅ "考虑通过接口抽象来解耦"
```

### 8. 面对新脚本的验证流程

#### 脚本兼容性检查清单

```
1. 语法验证：DSL解析器能否正确解析？
2. 意图覆盖：所有用到的意图是否正确定义？
3. 上下文依赖：需要的上下文变量是否合理？
4. 知识库需求：需要的数据是否在知识库中？
5. 流程完整性：是否有完整的开始→过程→结束？
6. 错误处理：是否有适当的兜底规则？
```

这套规范的核心思想是：**每个模块只做一件事，并且把它做好**。通过严格的职责分离和接口定义，我们可以确保系统的可维护性和可扩展性，避免在面对新脚本时出现意想不到的问题。

下次开发时，我们可以先对照这个规范，明确每个改动应该属于哪个模块的职责范围，然后再进行具体的编码工作。

---

## 9. 业务配置别名规范

### 别名设计原则

为避免匹配歧义和冲突，业务配置中的枚举别名应遵循以下规则：

#### 规则1：避免包含关系 - 使用区分度高的别名

**问题示例**：
```json
// ❌ 错误：M3的别名"m3"会被"m3 pro"包含
{
  "label": "M3",
  "aliases": ["m3"]
},
{
  "label": "M3 Pro", 
  "aliases": ["m3 pro"]
}
```

**解决方案**：
```json
// ✅ 正确：为基础选项添加区分性别名
{
  "label": "M3",
  "aliases": ["m3", "普通", "标准", "m3普通", "m3标准", "普通芯片"]
},
{
  "label": "M3 Pro",
  "aliases": ["m3 pro", "pro", "m3pro", "pro芯片", "三代pro"]
}
```

#### 规则2：仅保留子串别名 - 删除间接联想

**问题示例**：
```json
// ❌ 错误："深蓝"不是"午夜色"的子串，容易误匹配
{
  "label": "午夜色",
  "aliases": ["午夜色", "午夜", "深蓝", "暗蓝"]
}
```

**解决方案**：
```json
// ✅ 正确：仅保留是label子串的别名
{
  "label": "午夜色",
  "aliases": ["午夜色", "午夜"]
}
```

#### 规则3：数字别名完整性 - 避免单字符数字

**问题示例**：
```json
// ❌ 错误：数字"1"会被"18点"包含
{
  "label": "午餐时段",
  "aliases": ["午餐", "1", "12点"]
}
```

**解决方案**：
```json
// ✅ 正确：删除单字符数字，或使用完整数字串
{
  "label": "午餐时段",
  "aliases": ["午餐", "中午", "11点", "12点", "13点"]
}
```

#### 规则4：短词消歧 - 避免通用词冲突

**解决方案**：通过上下文消歧（系统会优先匹配缺失槽位）
已在`form_based_system.py`中实现上下文优先级匹配机制。

### 配置审查清单

新增或修改枚举配置时，必须通过以下检查：

- [ ] 是否有别名被其他别名包含？
- [ ] 所有别名是否都是label的子串或明确区分性描述？
- [ ] 是否使用了单字符数字作为别名？
- [ ] 短词别名是否会在多个槽位间造成冲突？

遵循这些规范可以显著减少别名匹配的歧义，提升系统的准确性和用户体验。
