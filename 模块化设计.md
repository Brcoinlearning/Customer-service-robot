# 模块化设计文档

## 1. 设计概述

### 1.1 设计目标

本项目采用模块化架构设计，旨在实现以下目标：

- **高内聚低耦合**：各模块职责明确，接口清晰
- **可扩展性**：易于添加新的功能模块
- **可维护性**：代码结构清晰，便于调试和测试
- **可测试性**：支持单元测试和集成测试

### 1.2 架构原则

- **接口隔离**：定义清晰的接口规范
- **依赖注入**：通过接口进行模块间通信
- **配置集中管理**：统一配置入口
- **上下文管理**：维护对话状态和上下文

## 2. 模块架构设计

### 2.1 整体模块结构

```
src/
├── core/                    # 核心抽象层
│   ├── interfaces.py        # 接口定义
│   └── context.py          # 上下文管理
├── config/                  # 配置层
│   └── settings.py         # 配置管理
├── parser/                  # DSL解析层
│   └── dsl_parser.py       # DSL解析器实现
├── interpreter/             # 业务逻辑层
│   └── interpreter.py      # 解释执行器实现
├── llm/                     # 外部服务层
│   └── spark_client.py     # LLM服务客户端
└── scripts/                 # 资源层
    └── ecommerce.dsl       # DSL脚本资源
```

### 2.2 模块依赖关系

```
main.py (应用入口)
    ↓
config/settings.py (配置)
    ↓
core/ (核心抽象)
    ├── interfaces.py (接口定义)
    └── context.py (状态管理)
        ↓
具体实现层
    ├── parser/dsl_parser.py (解析器)
    ├── interpreter/interpreter.py (执行器)
    └── llm/spark_client.py (LLM客户端)
```

## 3. 核心接口设计

### 3.1 IDSLParser 接口

```python
class IDSLParser(ABC):
    """DSL解析器接口 - 负责解析DSL脚本为内部数据结构"""
  
    @abstractmethod
    def parse(self, dsl_content: str) -> Dict[str, Any]:
        """
        解析DSL脚本内容
        Args:
            dsl_content: DSL脚本字符串
        Returns:
            解析后的数据结构，包含意图定义和规则定义
        """
```

**职责**：

- 语法解析和验证
- 生成抽象语法树(AST)
- 错误处理和语法检查

### 3.2 IInterpreter 接口

```python
class IInterpreter(ABC):
    """解释执行器接口 - 负责根据意图执行相应的业务规则"""
  
    @abstractmethod
    def execute(self, detected_intent: str, context: Dict[str, Any] = None) -> List[str]:
        """
        根据意图执行相应的规则
        Args:
            detected_intent: 检测到的用户意图
            context: 对话上下文信息
        Returns:
            响应消息列表
        """
```

**职责**：

- 规则匹配和选择
- 动作序列执行
- 上下文状态管理

### 3.3 ILLMClient 接口

```python
class ILLMClient(ABC):
    """LLM客户端接口 - 负责与大型语言模型API交互"""
  
    @abstractmethod
    def detect_intent(self, user_input: str, available_intents: Dict[str, str]) -> str:
        """
        使用LLM检测用户输入的意图
        Args:
            user_input: 用户输入文本
            available_intents: 可用的意图定义
        Returns:
            检测到的意图名称
        """
```

**职责**：

- LLM API调用管理
- 意图识别和分类
- 错误处理和降级策略

### 3.4 IContextManager 接口

```python
class IContextManager(ABC):
    """对话上下文管理器接口 - 负责维护对话状态"""
  
    @abstractmethod
    def get_context(self) -> Dict[str, Any]:
        """获取当前对话上下文"""
  
    @abstractmethod
    def update_context(self, key: str, value: Any):
        """更新对话上下文"""
```

**职责**：

- 对话历史管理
- 用户状态维护
- 变量存储和检索

## 4. 配置管理设计

### 4.1 Config 配置类

```python
class Config:
    """集中式配置管理 - 单例模式确保配置一致性"""
  
    # DSL配置
    DSL_SCRIPT_PATH = "src/scripts/ecommerce.dsl"
  
    # LLM配置
    LLM_API_KEY = os.getenv("SPARK_API_KEY", "default_key")
    LLM_API_URL = "https://spark-api-open.xf-yun.com/v1/chat/completions"
  
    # 业务配置
    MAX_HISTORY_LENGTH = 10
    RESPONSE_TIMEOUT = 30
```

**设计特点**：

- **环境变量支持**：通过环境变量覆盖默认配置
- **类型安全**：明确的配置项和默认值
- **易于扩展**：新增配置项无需修改使用代码

## 5. 上下文管理设计

### 5.1 ConversationContext 类

```python
class ConversationContext(IContextManager):
    """对话上下文管理实现"""
  
    def __init__(self):
        self._context = {
            "user_id": None,           # 用户标识
            "conversation_history": [], # 对话历史
            "current_intent": None,    # 当前意图
            "variables": {}           # 自定义变量
        }
```

**上下文数据结构**：

- **user_id**: 用户会话标识
- **conversation_history**: 对话历史记录（轮次控制）
- **current_intent**: 当前处理的意图
- **variables**: 业务变量存储（支持DSL脚本使用）

## 6. 数据流设计

### 6.1 正常执行流程

```
用户输入
    ↓
LLM意图识别 (ILLMClient)
    ↓
上下文更新 (IContextManager)
    ↓
DSL规则匹配 (IInterpreter)
    ↓
动作执行
    ↓
响应生成
```

### 6.2 错误处理流程

```
API调用失败
    ↓
降级策略（关键词匹配）
    ↓
默认规则执行
    ↓
错误信息返回
```

## 7. 扩展性设计

### 7.1 新增意图类型

```python
# 只需在DSL脚本中添加新的INTENT定义
INTENT new_intent: "新的意图描述"
```

### 7.2 新增条件类型

```python
# 在DSL解析器中扩展条件解析逻辑
def _parse_complex_condition(self, line: str):
    # 解析新的条件类型
```

### 7.3 新增动作类型

```python
# 在解释器中扩展动作执行逻辑
def _execute_custom_action(self, action: Dict):
    # 执行新的动作类型
```

## 8. 测试策略

### 8.1 单元测试

- **接口测试**：验证接口契约
- **模块测试**：各模块独立功能测试
- **边界测试**：异常输入处理

### 8.2 集成测试

- **数据流测试**：模块间协作测试
- **端到端测试**：完整业务流程测试

## 9. 部署和配置

### 9.1 环境配置

```bash
# 环境变量配置
export SPARK_API_KEY="your_api_key"
export DSL_SCRIPT_PATH="path/to/script.dsl"
```

### 9.2 依赖管理

```txt
# requirements.txt
requests>=2.25.1
pyyaml>=5.4.0
```

## 10. 总结

本模块化设计通过清晰的接口定义和分层架构，实现了：

- ✅ **可维护性**：各模块职责单一，便于修改
- ✅ **可测试性**：接口隔离，支持单元测试
- ✅ **可扩展性**：易于添加新功能
- ✅ **可靠性**：完善的错误处理和降级策略

该设计为后续的功能扩展和性能优化奠定了良好的架构基础。
