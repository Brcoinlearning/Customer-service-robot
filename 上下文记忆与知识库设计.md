# 上下文记忆与知识库设计

> 本文档用于补充说明本项目中“上下文记忆”和“产品知识库”这两部分的设计思路，
> 以及它们如何与 LLM 意图识别和 DSL 解释器结合，形成更自然的多轮对话体验。

---

## 1. 现状概览

### 1.1 上下文记忆（EnhancedConversationContext）

当前已有的上下文管理器 `EnhancedConversationContext` 已经支持：

- 基础对话信息：
  - `user_id`、`start_time`
  - `conversation_history`（最近 20 条消息）
- 对话状态与阶段：
  - `current_stage`（如 `welcome`、`brand_select` 等）
  - `state_history`（阶段演进轨迹）
- 产品选择链：
  - `product_chain`：按顺序记录 `category` / `subtype` / `brand` / `series`
  - `current_category` / `current_subtype` / `current_brand` / `current_series`
- 用户偏好与统计：
  - `user_preferences`（如偏好品牌）
  - `budget_range`（预算区间）
  - `usage_scenario`（使用场景）
  - `query_count`（产品咨询次数）

这些信息主要被 DSL 解释器用于：

- 规则条件判断：`CONTEXT_EQ`、`CONTEXT_NOT_SET`、`CONTEXT_STAGE_IS`、`CONTEXT_HAS`
- 动作执行：`SET_STAGE`、`SET_VAR`、`ADD_TO_CHAIN`、`RESET_SHOPPING_CONTEXT` 等

### 1.2 产品知识库（ProductKnowledge）

`ProductKnowledge` 已经维护了一棵结构化的产品知识树：

- 顶层品类（如“手机”“电脑”“智能设备”“影音娱乐”），包含：
  - `description`：文字描述
  - `icon`：表情图标
- 每个品类下的品牌列表（如“苹果”“华为”“联想”“戴尔”等），包含：
  - `series`：该品牌下的系列/型号列表
  - `scenarios`：适合的使用场景（办公、游戏、摄影等）
  - `price_range`：价格档位

提供的能力包括：

- `get_category_options()`：获取所有品类及其图标描述
- `get_brands_in_category(category)`：获取指定品类下的品牌列表
- `get_series_in_brand(category, brand)`：获取某品类某品牌下的系列
- `get_recommendations_by_scenario(category, scenario)`：按使用场景推荐品牌+系列
- `search_products(keyword)`：按关键词搜索品类/品牌/系列

目前这些能力主要在单元测试和少量示例代码中使用，还没有深度融入对话流程。

---

## 2. 问题与优化方向总览

围绕“上下文记忆 + 产品知识库”，我们希望解决两个核心问题：

1. **意图识别时 LLM 对上下文不敏感**：
   - 当前 `SparkLLMClient.detect_intent` 只看当轮的 `user_input`，没有看到阶段、产品链等信息；
   - 对“继续”“好的”“就这个”这类短语的理解严重依赖解释器里的手工修正逻辑。
2. **DSL 文案与知识库数据割裂**：
   - DSL 中写死了大量品牌/系列列表，例如“苹果、华为、小米、三星”等；
   - `ProductKnowledge` 中也维护了品牌/系列，两边容易不一致，且无法根据用户上下文动态推荐。

对应地，我们提出两个优化方向：

- **4.1 上下文参与 LLM 提示词**：
  - 让意图识别不仅依赖当前一句话，还能“看到”当前阶段和已选产品链，提高对含糊表达的理解能力。
- **4.2 用 DSL 动作驱动 ProductKnowledge**：
  - 通过新的 DSL 动作（如 `SUGGEST_BRANDS` / `SUGGEST_SERIES`）调用知识库，让推荐内容始终与结构化数据一致，并为个性化推荐预留空间。

下面分别展开说明这两个方向的设计。

---

## 3. 设计一：上下文参与 LLM 提示词（4.1）

### 3.1 改造前的局限

当前的 `SparkLLMClient.detect_intent` 接口为：

- 输入：`user_input: str`，`available_intents: Dict[str, str]`
- 内部逻辑：
  - 简单确认词/否定词直接返回 `confirmation`；
  - 否则构造一段“意图列表 + 用户输入”的提示词，让 LLM 返回意图名称；
  - 出错时退回 `_fallback_intent_detection` 的关键词匹配。

局限在于：

1. **对话阶段缺失**：
   - 在 `cart_added` 阶段说“继续”，和在 `brand_select` 阶段说“继续”，含义不同；
   - 现在 LLM 完全不知道当前处于哪个阶段，需要解释器在事后做修正（比如 cart 阶段数字强制转成 `cart_operation`）。
2. **产品选中链缺失**：
   - 当用户说“就刚才那个电脑再详细说说”，
   - LLM 看不到当前 `product_chain`（电脑→笔记本→苹果），很难准确判断是继续配置当前产品，还是重新选品类。
3. **对历史对话不敏感**：
   - 没有使用 `conversation_history` 中的最近几条上下文，
   - 对“换一个”“再推荐几款”之类的表达理解能力有限。

### 3.2 改造思路

在保持接口简单的前提下，我们计划将 `detect_intent` 扩展为支持可选的上下文参数：

```python
# 接口层（ILLMClient）
def detect_intent(self, user_input: str, available_intents: Dict[str, str], context: Dict[str, Any] | None = None) -> str:
    ...
```

在 `main.py` 中调用时，改为：

1. 在调用 LLM 之前，从 `EnhancedConversationContext` 获取当前上下文：
   - `current_stage`
   - `current_category` / `current_subtype` / `current_brand` / `current_series`
   - 最近若干条对话（例如最后 3～5 条）
   - `product_chain`（用于生成“电脑 → 笔记本 → 苹果”这样的链路描述）
2. 构造一个简短的“上下文摘要”字符串传给 LLM 客户端：

   ```text
   当前对话阶段: brand_select
   当前已选产品链: 电脑 -> 笔记本 -> 苹果
   最近对话摘要:
   - 用户: 我想买电脑
   - 系统: 好的，您想买电脑。目前我们有：笔记本电脑、台式机。
   - 用户: 苹果的
   ```

3. 在 `SparkLLMClient.detect_intent` 内部，将这一段上下文插入到 prompt 中，让 LLM 在分类时“感知当前所处的步骤”。

### 3.3 预期体验提升

1. **对模糊短语的理解更准确**：
   - 在购物车阶段说“继续”，上下文中有 `current_stage = cart_added`，提示中明确说明“此时用户在购物车界面”，LLM 更易倾向于 `cart_operation`；
   - 在品牌选择阶段说“继续”，上下文中有 `current_stage = brand_select`，更易维持在 `product_query` 下的品牌/系列流程。

2. **多轮对话更连贯**：
   - 用户说“刚才那个再换个配置”，结合 `product_chain` 和对话历史，
     LLM 可以更好地理解是在“当前产品基础上调整”，而不是重新开始。

3. **解释“系统智能性”更有说服力**：
   - 在课程报告/答辩中，可以强调：
     > 我们不仅在 DSL 解释器中使用上下文，还在 LLM 意图识别阶段将阶段信息和产品选择链作为提示，
     > 让 LLM 对“继续”“好的”等短语做出上下文相关的判断。

---

## 4. 设计二：用 DSL 动作驱动产品知识库（4.2）

### 4.1 改造前的局限

当前 `ProductKnowledge` 已经维护了结结构化的：

- 品类 → 品牌 → 系列 → 场景 → 价格区间

但在 DSL 中仍然存在大量硬编码的文案，例如：

```dsl
RESPOND "目前主流手机品牌有：苹果、华为、小米、三星等。"
RESPOND "联想、戴尔、惠普、华硕等。您偏好哪个品牌？"
```

这带来几个问题：

1. **知识重复维护、容易不一致**：
   - 品牌/系列在 `ProductKnowledge` 中维护一份，
   - 在 DSL 文案里又写了一份；
   - 后续新增或修改品牌时容易“改了知识库没改文案”。

2. **无法根据用户上下文动态推荐**：
   - 即使 `EnhancedConversationContext` 知道用户偏好“办公 + 预算 4000 左右”，
   - DSL 仍然只是机械地列出所有品牌/系列，缺少“推荐理由”。

3. **课程展示上不够“结构化”**：
   - 虽然实现了一个知识库类，但业务逻辑仍然主要通过固定字符串展示，
   - 不足以体现“知识驱动对话”的设计亮点。

### 4.2 改造思路：新增 DSL 动作调用 ProductKnowledge

我们计划在 DSL 中引入新的动作指令，例如：

- `SUGGEST_BRANDS`：根据当前上下文中的 `current_category`，调用知识库动态生成品牌列表文案；
- `SUGGEST_SERIES`：根据 `current_category` + `current_brand`，调用知识库动态生成系列/型号列表文案；

解析层面：

- 在 `dsl_parser.py` 的 `_parse_action` 中增加对 `SUGGEST_BRANDS` / `SUGGEST_SERIES` 的识别：
  - 生成动作类型 `suggest_brands` / `suggest_series`。

解释层面：

- 在 `DSLInterpreter` 中：
  - 为 `_action_handlers` 增加 `suggest_brands` / `suggest_series` 的处理函数；
  - 在这些 handler 中，通过 `context["knowledge"]` 获取 `ProductKnowledge` 实例；
  - 根据 `current_category`、`current_brand` 调用：

    ```python
    brands = knowledge.get_brands_in_category(current_category)
    series = knowledge.get_series_in_brand(current_category, current_brand)
    ```

  - 再拼接为用户可读的文案，例如：

    ```text
    目前手机主流品牌有：苹果、华为、小米、OPPO 等。
    您更倾向哪个品牌？
    ```

DSL 规则层面：

- 在 `ecommerce.dsl` 中，新增若干使用这些动作的规则，例如：
  - 在 `brand_select` 阶段，当用户问“有哪些品牌”“推荐品牌”时：

    ```dsl
    RULE product_query_list_brands_dynamic
    WHEN INTENT_IS product_query
        AND CONTEXT_STAGE_IS "brand_select"
        AND USER_MENTION_ANY "有哪些品牌|推荐品牌|品牌有哪些"
    THEN
        SUGGEST_BRANDS
    ```

  - 在 `series_select` 阶段，当用户问“有哪些系列”“推荐型号”时：

    ```dsl
    RULE product_query_list_series_dynamic
    WHEN INTENT_IS product_query
        AND CONTEXT_STAGE_IS "series_select"
        AND USER_MENTION_ANY "有哪些系列|推荐系列|推荐型号"
    THEN
        SUGGEST_SERIES
    ```

### 4.3 预期体验提升

1. **品牌/系列列表始终与知识库同步**：
   - 后续只需在 `ProductKnowledge` 中更新品牌树，
   - `SUGGEST_BRANDS` / `SUGGEST_SERIES` 自动展示最新配置，避免“文案忘记更新”的问题。

2. **为个性化推荐预留空间**：
   - 未来可在 `ProductKnowledge` 内根据 `usage_scenario`、`budget_range` 等字段，
     对品牌/系列进行简单打分或排序，
   - `SUGGEST_SERIES` 可优先展示更符合用户偏好的方案，形成“知识 + 记忆驱动”的推荐逻辑。

3. **项目展示更具“结构化设计”特色**：
   - 在答辩中可以强调：
     > DSL 不仅用于静态规则，还可以通过动作调用结构化的产品知识库，
     > 将“业务逻辑（规则）”与“业务数据（知识库）”解耦，便于维护和拓展。

---

## 5. 后续可选扩展

在完成 4.1 + 4.2 的基础能力后，还可以进一步考虑：

1. **基于场景的推荐动作**：
   - DSL 中新增如 `SUGGEST_BY_SCENARIO "办公"` 的动作，调用 `get_recommendations_by_scenario`，
   - 将“办公/游戏/摄影”等自然语言场景与结构化推荐结合起来。

2. **对话摘要参与提示词**：
   - 利用 `get_conversation_summary()` 的输出，构造更紧凑的对话摘要，
   - 在提示词中使用“当前选择摘要 + 使用场景 + 历史查询次数”等信息，进一步增强 LLM 的上下文理解。

3. **知识库与 DSL 的双向联动**：
   - 约定 DSL 中某些关键字（如品类、品牌名）必须来自 `ProductKnowledge` 的集合，
   - 通过简单脚本在开发阶段做一致性检查，避免“DSL 写了不存在的品牌”。

以上设计内容会在实现 4.1 / 4.2 时逐步落地，并在开发日志中记录对应的阶段与测试结果。

